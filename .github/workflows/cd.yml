name: Deploy

on:
  workflow_run:
    workflows: ["Backend_Tests"]
    types: [completed]
    branches: ["main", "master", "ci/cd"] # æ˜ç¢ºæŒ‡å®šåˆ†æ”¯
  workflow_dispatch:

jobs:
  deploy:
    runs-on: self-hosted
    # ä¿®æ”¹æ¢ä»¶ï¼šå…è¨± workflow_runï¼Œä½†è¦æ±‚å®ƒæˆåŠŸ
    if: |
      github.event_name == 'workflow_dispatch' || 
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')

    steps:
      - name: éƒ¨ç½²ç‹€æ…‹æª¢æŸ¥
        run: |
          echo "è§¸ç™¼äº‹ä»¶: ${{ github.event_name }}"
          echo "å·¥ä½œæµç¨‹åç¨±: ${{ github.workflow }}"
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            echo "å‰ç½®å·¥ä½œæµç¨‹çµè«–: ${{ github.event.workflow_run.conclusion }}"
            echo "å‰ç½®å·¥ä½œæµç¨‹åˆ†æ”¯: ${{ github.event.workflow_run.head_branch }}"
          fi

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create .env file
        run: |
          if [ -n "${{ secrets.ENV_FILE }}" ]; then
            # GitHub Actionsï¼šå¾ Secret å¯«å…¥ .env
            echo "${{ secrets.ENV_FILE }}" > .env
            echo "âœ… .env å·²å¾ GitHub Secret å»ºç«‹"
          elif [ -f ".env" ]; then
            # æœ¬åœ° act æ¸¬è©¦ï¼šç›´æ¥ä½¿ç”¨ç¾æœ‰çš„ .env
            echo "âœ… ä½¿ç”¨ç¾æœ‰æœ¬åœ° .env æª”æ¡ˆ"
          else
            echo "âŒ æ‰¾ä¸åˆ° .env è¨­å®šï¼ˆGitHub Secret ENV_FILE æœªè¨­å®šä¸”æœ¬åœ°ç„¡ .envï¼‰"
            exit 1
          fi

      - name: Docker Compose é‡å•Ÿ
        run: |
          echo "ğŸš€ é–‹å§‹éƒ¨ç½²..."

          # âš ï¸  åªé‡å»º Application å±¤å®¹å™¨ï¼ˆbackend + nginxï¼‰
          # MySQL å’Œ Redis ä¸é‡å•Ÿ â€” é¿å…è³‡æ–™éºå¤±æˆ–å¿«å–æ¸…ç©º
          docker compose up -d --build --no-deps backend1 backend2 backend3 nginx
          docker image prune -f

          echo "âœ¨ éƒ¨ç½²å®Œæˆ $(date)"

      # â”€â”€ Post-Deploy Smoke Tests â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Wait for services to be healthy
        run: |
          echo "â³ ç­‰å¾…æœå‹™å•Ÿå‹•..."
          MAX_ATTEMPTS=18  # 18 * 5s = 90s
          ATTEMPT=0
          until [ $ATTEMPT -ge $MAX_ATTEMPTS ]; do
            if curl -sf http://localhost/health > /dev/null 2>&1; then
              echo "âœ… æœå‹™å·²å°±ç·’"
              exit 0
            fi
            ATTEMPT=$((ATTEMPT + 1))
            echo "  å˜—è©¦ $ATTEMPT/$MAX_ATTEMPTSï¼Œç­‰å¾… 5 ç§’..."
            sleep 5
          done
          echo "âŒ æœå‹™å•Ÿå‹•è¶…æ™‚ï¼ˆè¶…é 90 ç§’ï¼‰"
          exit 1

      - name: Smoke test â€” Health endpoint
        run: |
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost/health)
          echo "Health check HTTP status: $STATUS"
          [ "$STATUS" = "200" ] || (echo "âŒ Health check å¤±æ•—" && exit 1)
          echo "âœ… Health check é€šé"

      - name: Smoke test â€” /nearby API
        run: |
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            "http://localhost/nearby?lat=25.033&lng=121.565&radius=3000")
          echo "/nearby HTTP status: $STATUS"
          [ "$STATUS" = "200" ] || (echo "âŒ /nearby API å¤±æ•—" && exit 1)
          echo "âœ… /nearby API é€šé"

      - name: Smoke test â€” Redis circuit state
        run: |
          RESP=$(curl -s http://localhost/health/redis || echo "{}")
          echo "Redis circuit state: $RESP"
          echo "$RESP" | grep -q '"activeClient"' || \
            (echo "âŒ Redis health endpoint ç•°å¸¸" && exit 1)
          echo "âœ… Redis health endpoint é€šé"

      - name: Verify all containers are running
        run: |
          echo "ğŸ” æª¢æŸ¥å®¹å™¨ç‹€æ…‹..."
          FAILED=0
          for container in mysql_db redis_local backend_app_1 backend_app_2 backend_app_3 nginx_proxy; do
            STATUS=$(docker inspect --format='{{.State.Status}}' $container 2>/dev/null || echo "missing")
            echo "  $container â†’ $STATUS"
            [ "$STATUS" = "running" ] || { echo "  âŒ $container æœªæ­£å¸¸é‹è¡Œ"; FAILED=1; }
          done
          [ "$FAILED" = "0" ] && echo "âœ… æ‰€æœ‰å®¹å™¨æ­£å¸¸" || exit 1
